\documentclass[11pt]{article}
\usepackage{geometry}
\geometry{letterpaper, margin=1in}
\usepackage{times}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{titlesec}
\usepackage{enumitem}

\titleformat{\section}{\bfseries\large}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\bfseries}{\thesubsection}{0.5em}{}

\title{\textbf{P2P Distributed Chat: A Decentralized Communication System}}
\author{
    Arthur Chen (ac820) \\
    Shuqi Shen (ss1481) \\
    Jay Yoon (jy320) \\
    Jingheng Huan (jh730)
}
\date{}

\begin{document}
\maketitle

\begin{abstract}
This report presents a fully decentralized peer-to-peer (P2P) chat system developed as part of the CS512 Distributed Systems course. Unlike traditional chat architectures that rely on centralized messaging servers, our system utilizes WebRTC DataChannels for direct client-to-client communication. Firebase Firestore is used solely for connection signaling, while all real-time messaging bypasses server infrastructure entirely. We further developed a minimal NestJS backend exclusively to support quick-match pairing. Our system demonstrates distributed coordination, NAT traversal, low-latency communication, and decentralized state management. Experimental evaluation shows message latency consistently below 20 ms under typical network environments. However, challenges related to NAT configurations, signaling race conditions, and session persistence emerged. This paper details the architecture, implementation, evaluation, and lessons learned while building a fully decentralized communication system, offering insights into practical distributed system design in modern web environments. The complete source code for this project is available at \url{https://github.com/JayYoon0412/p2p-chat}.
\end{abstract}


% =============================== INTRO ===============================

\section{Introduction}

Real-time messaging applications play a critical role in modern digital communication. Traditionally, such applications rely on centralized back-end servers that mediate message delivery, manage user states, and coordinate message sequencing. Although this architecture provides control and reliability, it inevitably introduces latency, scalability constraints, and single points of failure. Emerging web standards and decentralized networking technologies challenge the need for centralized mediation, particularly in light of browser-native capabilities such as WebRTC. This project investigates whether real-time communication can be achieved entirely via peer-to-peer (P2P) channels between clients, thereby removing messaging servers from the communication loop.

\subsection{Motivation}

The primary motivation is to explore how distributed system concepts can be applied to the problem of real-time communication without relying heavily on backend services. As messaging applications scale, server costs and maintenance requirements grow proportionally. Additionally, routing messages through a server increases network latency, especially when users are geographically distant from the server. By using WebRTC DataChannels for browser-based direct communication, we aim to reduce this latency and investigate new forms of decentralized message exchange.

More broadly, the project serves as a hands-on exploration of decentralization principles taught in the course. Topics such as distributed coordination, state consistency, and reliability are usually studied in the context of large-scale backend infrastructure. Our system demonstrates that these challenges also exist in peer-hosted environments and must be carefully addressed even in small-scale applications.

\subsection{Problem Statement}

Implementing P2P messaging without a backend introduces several obstacles. First, two independent clients must locate each other and initiate a secure connection without prior knowledge of their network addresses. This step, known as signaling, usually requires a dedicated server. We seek to determine whether a real-time database such as Firestore can serve as a substitute while maintaining low overhead.

Second, the system must establish and maintain a communication channel that achieves sufficiently low latency. We investigate whether WebRTC-based communication can consistently outperform traditional server-mediated messaging.

Third, the absence of a centralized server shifts responsibilities such as reconnection, state synchronization, and reliability toward clients. This paper studies how such responsibilities are redistributed and how to mitigate emerging risks.

Formally, we aim to answer:

\begin{enumerate}[noitemsep]
    \item Can two web clients reliably establish P2P communication without a centralized relay server?
    \item Is Firestore a viable alternative for signaling compared to a dedicated WebSocket server?
    \item What are the trade-offs in reliability, performance, and engineering complexity?
\end{enumerate}

\subsection{Objectives}

Our project objectives are to:
\begin{enumerate}[noitemsep]
    \item Implement direct P2P communication using WebRTC DataChannels.
    \item Use Firestore exclusively for signaling metadata exchange.
    \item Evaluate performance across different network configurations.
    \item Analyze the implications on distributed system reliability.
\end{enumerate}

Through this work, we demonstrate that decentralized messaging is feasible using modern web technologies, though not without trade-offs.

% =============================== ARCHITECTURE ===============================

\section{System Architecture}

\subsection{Overview}

The system follows a three-layer architecture:

\begin{center}
\begin{tabular}{|c|}
\hline
Client Application Layer (React) \\
\hline
P2P Communication Layer (WebRTC DataChannel) \\
\hline
Signaling Layer (Firebase Firestore) \\
\hline
\end{tabular}
\end{center}

Unlike centralized chat systems, our server does not participate in message exchange and merely aids in user pairing. Once peers connect, communication proceeds entirely via WebRTC, ensuring minimal routing overhead and full decentralization.

\subsection{Signaling Layer}

Signaling metadata is exchanged via Firestore in the form of SDP (Session Description Protocol) offers and answers. This layer acts as the initial coordination mechanism before the direct P2P link is established. Each room acts as a synchronization point using the following data model:

\begin{itemize}
    \item \texttt{rooms/\{roomId\}}: The main document containing the session state.
    \item Fields: \texttt{offer}, \texttt{answer}, \texttt{state}, \texttt{createdAt}, \texttt{type}.
    \item Subcollections: \texttt{caller/candidates}, \texttt{callee/candidates} for incremental ICE candidate exchange.
\end{itemize}

The signaling process follows a strict state machine to ensure convergence:
\[
\texttt{waiting} \rightarrow \texttt{offered} \rightarrow \texttt{answered} \rightarrow \texttt{connected}
\]

Using \texttt{onSnapshot} listeners, each peer monitors these state changes in real time. This approach mirrors WebSocket functionality without requiring a dedicated stateful backend, effectively leveraging Firestore as a distributed shared memory.

We occasionally encountered race conditions where ICE candidates arrived before SDP processing was complete. To mitigate this, candidates were temporarily cached until both local and remote SDP descriptors were successfully applied.

\subsection{Peer-to-Peer Layer}

The core communication channel relies on the WebRTC DataChannel API. We prioritized message ordering and security over raw throughput, leading to the following configuration:

\begin{itemize}
    \item \textbf{Channel Name}: \texttt{chat}
    \item \textbf{Ordered}: \texttt{true} (ensures messages arrive in sequence, preventing conversational desynchronization)
    \item \textbf{Encryption}: DTLS (Datagram Transport Layer Security) is mandated by the WebRTC standard, ensuring end-to-end privacy.
\end{itemize}

To facilitate connectivity across different networks, we employed public STUN servers from Google (\texttt{stun.l.google.com:19302}) and Twilio (\texttt{global.stun.twilio.com:3478}). These servers allow clients to discover their public IP addresses and port mappings.

The connection state machine monitored by the client is:
\[
\text{idle} \rightarrow \text{signaling} \rightarrow \text{connecting} \rightarrow \text{connected}
\]

While STUN handles Full Cone NATs effectively, Symmetric NATs proved problematic. A TURN (Traversal Using Relays around NAT) server was omitted to keep the infrastructure minimal, which is a known limitation in our current deployment affecting approximately 13\% of cross-network connection attempts in our tests.

\subsection{Client Interface Layer}

Developed using React and TypeScript, the interface provides:
\begin{itemize}
    \item Room creation and joining
    \item Quick-match peer allocation
    \item Chat messaging and connection status visualization
\end{itemize}

The UI reflects WebRTC connection state dynamically and informs users of connectivity issues. Figures \ref{fig:ui_jingheng} and \ref{fig:ui_arthur} demonstrate the user interface during an active chat session between two peers.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Jingheng.png}
    \caption{Client Interface: Peer 1 (Jingheng) View}
    \label{fig:ui_jingheng}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Arthur.png}
    \caption{Client Interface: Peer 2 (Arthur) View}
    \label{fig:ui_arthur}
\end{figure}

\subsection{Server Responsibilities}

The NestJS backend supports only quick-match pairing with one HTTP endpoint:

\begin{verbatim}
POST /quick-match
\end{verbatim}

If a user is the first to arrive, the server returns \texttt{waiting + roomId}. If paired, the response is \texttt{paired + roomId}. The server does not relay communication.

% =============================== DESIGN ===============================

\section{Design Decisions}

\subsection{Firestore vs. WebSocket Signaling}

We chose Firebase Firestore as our signaling mechanism instead of a custom WebSocket server.
\begin{itemize}
    \item \textbf{Rationale}: Firestore provides a managed, serverless real-time database. This eliminated the need to maintain a stateful signaling server, reducing operational complexity. Its \texttt{onSnapshot} capability provides the necessary event-driven updates for SDP exchange.
    \item \textbf{Trade-offs}: While simpler to deploy, Firestore writes introduce slightly higher latency (hundreds of milliseconds) compared to raw WebSockets. However, since signaling only occurs once per session, this setup delay is acceptable for the benefit of reduced infrastructure maintenance.
\end{itemize}

\subsection{WebRTC for Communication}

WebRTC was selected to achieve true peer-to-peer communication.
\begin{itemize}
    \item \textbf{Latency}: By bypassing a central relay server, message latency is determined solely by the network path between peers, often resulting in faster delivery than server-routed architectures.
    \item \textbf{Privacy}: The architectural design ensures that message content never passes through our backend or database, providing inherent privacy (though metadata exists in Firestore).
\end{itemize}
However, this introduced complexity in handling ICE negotiation failures and connection recovery, tasks typically handled by a central server in traditional architectures.

\subsection{Ordered DataChannel}

We explicitly configured the WebRTC DataChannel with \texttt{ordered: true}.
\begin{itemize}
    \item \textbf{Rationale}: In a chat application, message sequence is critical for context. Out-of-order delivery would confuse users.
    \item \textbf{Trade-off}: Ordered delivery can suffer from head-of-line blocking in poor network conditions, where one lost packet delays all subsequent messages. We accepted this risk to ensure conversational coherency.
\end{itemize}

\subsection{Exclusion of TURN Servers}

TURN servers significantly improve connectivity under corporate or symmetric NAT by relaying traffic when direct P2P fails.
\begin{itemize}
    \item \textbf{Decision}: We intentionally excluded TURN servers.
    \item \textbf{Reasoning}: TURN servers require high-bandwidth hosting and increase costs significantly. Given the project's scope as an academic exploration of P2P mechanics, we prioritized architectural simplicity and accepted the lower connection success rate in restrictive networks.
\end{itemize}

\subsection{Minimal Server Design}

The NestJS backend was intentionally limited to a single responsibility: \texttt{/quick-match}.
\begin{itemize}
    \item \textbf{Statelessness}: The server maintains an in-memory queue of waiting users but does not persist session state.
    \item \textbf{Implication}: If the server restarts, the queue is cleared. This decision adheres to the decentralized philosophy, the server is a mere facilitator, not a dependency for ongoing chats. Once paired, users do not interact with the server again.
\end{itemize}

% =============================== IMPLEMENTATION ===============================

\section{Implementation}

\subsection{Technology Stack}

\begin{itemize}
    \item Frontend: React 19 with TypeScript
    \item Backend: NestJS (Node.js)
    \item Signaling Database: Firebase Firestore
    \item Communication Protocol: WebRTC
\end{itemize}

\subsection{Message Format}

\begin{verbatim}
{
  "t": "chat",
  "text": "Hello"
}
\end{verbatim}

WebRTC supports custom data serialization, and future improvements could introduce typing indicators or delivery receipts.

% =============================== TESTING ===============================

\section{Testing and Evaluation}

\subsection{Experimental Setup}

Tests were conducted with two users across:
\begin{enumerate}[noitemsep]
    \item Same Wi-Fi network
    \item Cross-network peers
    \item Corporate firewall environments
\end{enumerate}

Latency measurements were recorded using timestamp-based comparisons.

\subsection{Results}

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
Scenario & Setup Time & Latency & Success Rate \\
\hline
Same Network & 1.2s & < 15ms & 100\% \\
Different Network & 2.3s & < 20ms & 87\% \\
Corporate Firewall & 6s+ & N/A & 40\% \\
\hline
\end{tabular}
\end{center}

\subsection{Analysis}

Once established, WebRTC connections consistently outperformed centralized alternatives. However, setup failures mainly stemmed from ICE negotiation problems and lack of TURN servers.

% =============================== WHAT WE DID ===============================

\section{What We Did}

Our team collaboratively developed a full-stack decentralized chat application. The specific contributions include:

\begin{itemize}
    \item \textbf{Frontend Development}: Built a responsive React 19 application with TypeScript that manages complex WebRTC state transitions and provides real-time feedback to users.
    \item \textbf{Signaling Infrastructure}: Implemented a robust signaling protocol on top of Firestore, handling race conditions and state synchronization.
    \item \textbf{Backend Engineering}: Developed a lightweight NestJS server to handle atomic user pairing for the "Quick-Match" feature.
    \item \textbf{Integration \& Testing}: Conducted cross-network testing to validate NAT traversal strategies and measure latency performance.
\end{itemize}

Integration testing focused heavily on the signaling phase, ensuring that the transition from the Firestore-mediated handshake to the direct P2P connection was seamless and reliable.

\subsection{Use of AI Assistants}
We utilized AI-powered coding assistants, specifically Cursor and Gemini 3 Pro, to accelerate development. These tools were used to:
\begin{itemize}
    \item Generate boilerplate code for React components and NestJS controllers.
    \item Debug intricate WebRTC configuration issues and race conditions.
    \item Refine the technical language and structure of this report.
\end{itemize}
All architectural decisions, system designs, and core logic were formulated and reviewed by the team to ensure correctness and adherence to project requirements.

% =============================== WHAT WE LEARNED ===============================

\section{What We Learned}

We learned that database-driven coordination is viable for decentralized setups. WebRTC enables low-latency communication but requires deep networking knowledge to manage negotiation. Simplifying infrastructure does not simplify failure behavior. Finally, built-in encryption significantly reduces security concerns.

% =============================== UNEXPECTED PROBLEMS ===============================

\section{Unexpected Problems}

\subsection{NAT Traversal and Symmetric NATs}
While STUN servers successfully resolved IP addresses for most home networks, we encountered significant issues with Symmetric NATs (often found in corporate or university environments). In these cases, the NAT maps internal IP:port pairs to different external ports for different destinations, causing P2P connection attempts to fail. Without a TURN server to relay traffic, these connections could not be established. This highlighted the "real-world" difficulty of pure P2P systems compared to server-relayed architectures.

\subsection{Signaling Race Conditions}
The asynchronous nature of Firestore updates led to race conditions. For instance, a peer might receive a remote ICE candidate before the remote SDP offer had been fully processed.
\textbf{Solution}: We implemented a local buffering queue for ICE candidates. Candidates received early are stored and only added to the \texttt{RTCPeerConnection} once the \texttt{setRemoteDescription} promise resolves.

\subsection{Queue Reset on Server Restart}
Our decision to use an in-memory array for the quick-match queue meant that any server deployment or restart would clear pending users.
\textbf{Impact}: Users currently waiting in the queue would be "orphaned", stuck waiting for a match that would never arrive.
\textbf{Lesson}: Even "stateless" services often require some persistent state (e.g., Redis) to handle service interruptions gracefully.

\section{Code Availability}
The complete source code for this project, including the client application, server backend, and documentation, is available on GitHub:

\begin{center}
\url{https://github.com/JayYoon0412/p2p-chat}
\end{center}

Instructions for running the application locally or deploying it are provided in the repository's \texttt{README.md}.

% =============================== FUTURE WORK ===============================

\section{Future Work}

\begin{enumerate}[noitemsep]
    \item Add TURN servers for higher reliability.
    \item Support mesh or SFU topologies for group chat.
    \item Introduce message persistence and offline handling.
    \item Improve reconnection strategies.
\end{enumerate}

% =============================== CONCLUSION ===============================

\section{Conclusion}

This project demonstrates the feasibility of decentralized browser-to-browser communication using WebRTC for direct messaging and Firestore for lightweight coordination. By eliminating centralized messaging servers, we significantly reduced latency and gained insight into distributed system architectures at the client level. While reliability issues remain under constrained network setups, this work highlights that decentralized systems can achieve robust communication within modern web ecosystems without extensive backend support.

The project deepened our understanding of trade-offs between latency and reliability, and challenged traditional assumptions around centralized architecture in communication applications.

% =============================== REFERENCES ===============================

\section{References}
\begin{itemize}[leftmargin=*]
    \item WebRTC Specification: \url{https://www.w3.org/TR/webrtc/}
    \item Firebase Firestore Documentation: \url{https://firebase.google.com/docs/firestore}
    \item NestJS Documentation: \url{https://docs.nestjs.com/}
    \item React Documentation: \url{https://react.dev/}
\end{itemize}

\end{document}
